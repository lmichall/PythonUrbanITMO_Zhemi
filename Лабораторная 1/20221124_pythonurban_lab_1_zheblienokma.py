# -*- coding: utf-8 -*-
"""20221124_PythonUrban_lab_1_ZheblienokMA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gsz9E-N-s7JGDmidee0jfvy8kNBpqXCD

## list comprehension

### Обработка каждого элемента
"""

cart = [3, 4, 12, 17, 19, 21, 23, 26, 30]

cashier = []  # новый список с помощью метода append
for item in cart:
    cashier.append(item)
print(cashier)

cashier = [item for item in cart]
print(cashier)

"""![](https://github.com/mrdbourke/python-list-comprehensions-tutorial/raw/f68f956c745932e1b824a69994706d715adde0a1/images/list-comprehensions-1.png)

### Фильтрация элементов
"""

cart = [5, 7, 9, 10, 12, 15, 19, 20, 22]

cashier_3 = []
for item in cart:
    if item % 2 == 0:  # только четные
        cashier_3.append(item)
print(cashier_3)

cashier_3 = [item for item in cart if item % 2 == 0]
print(cashier_3)

"""![](https://github.com/mrdbourke/python-list-comprehensions-tutorial/raw/f68f956c745932e1b824a69994706d715adde0a1/images/list-comprehensions-2.png)

## Задачи

##### ***Задача 1. Сделать название городов с заглавной буквы.***
Написать функцию task_1, которая будет принимать список названий городов, а возвращать новый список, в котором в каждой строке первая буква будет заглавной, а все остальные строчные.
"""

list_cities = ["москва", "иЖЕВСк", "Владивосток", "новосибирсК", "мУРМАНСК"]

def task_1(list_):
    '''
    В новый список добавляются значения, где в каждой строке первая буква заглавная с помощью метода title()
    Пробовал через цикл, но с list comprehension получается изящнее
    list_new = []
    for i in list_cities:
        list_new.append(i.title())
    return list_new
    '''
    return [name_city.title() for name_city in list_]


new_list_cities = task_1(list_cities) 

print(f'Список с исправленными названиями городов - {new_list_cities}')  # ['Москва', 'Ижевск', 'Владивосток', 'Новосибирск', 'Мурманск']

"""##### ***Задача 2. Отфильтровать города с населением больше 1 млн. человек.***

Написать функцию task_2, которая будет принимать два аргумента список городов и численность населения.  
Функция должна возвращать новый отфильтрованный список городов, где остались города только с население больше 1 млн. человек


"""

list_dict_cities = [
    {
        "name": "Москва",
        "population": 12 * 10 ** 6,
    },
    {
        "name": "Санкт-Петербург",
        "population": 5 * 10 ** 6,
    },
    {
        "name": "Ижевск",
        "population": 0.6 * 10 ** 6,
    },
]

filter_population = 10 ** 6

def task_2(list_, filter_task):
    '''
    Функция поиска городов с населением более 1 млн. чел.
    По условию создается новый список
    Сначала пробовал через цикл
    new_list = []
    for i in list_:
        if i["population"] >= filter_task:
            new_list.append(i)
    return new_list
    
    ВОПРОС: насколько уместно здесь использовать "population" - ведь это не константа? и не локальная переменная?
    '''
    return [city for city in list_ if city["population"] >= filter_task]


new_list_dict_cities = task_2(list_dict_cities, filter_population) 

print(f'Города с населением более 1 млн. - {new_list_dict_cities}')  # [{'name': 'Москва', 'population': 12000000}, {'name': 'Санкт-Петербург', 'population': 5000000}]

"""##### ***Задача 3. Найти общие города среди двух групп и отсортировать их в алфавитном порядке.***

Написать функцию task_3, которая будет принимать 2 списка городов, а возвращать новый список, в котором будут города, которые есть в двух группах.  
Результат функции должен быть отсортирован в алфавитном порядке. 

"""

fisrt_group = ["Москва", 'Владивосток', "Санкт-Петербург"]
second_group = ['Новосибирск', "Ижевск", "Санкт-Петербург", "Москва"]

def task_3(first, second):
    '''
    Функция на поиск общих значений в разных списках
    с помощью метода пересечения множеств

    До этого пробовал циклом (с добавлением проверки на повторяющиеся значения в списках)
    new_list = []
    for i in first:
        if i in new_list:
            continue
        for j in second:
            if i == j:
                new_list.append(i)
                break
    return sorted(new_list)
    
    return list(set(first).intersection(second)).sort()

    можно было бы с помощью list comprehension, но отстутствует
    проверка на дубликаты и сортировку (ВОПРОС: или можно как-то добавить?)
    return [i for i in first if i in second]
    '''
    return sorted(set(first).intersection(second)) 

common_cities = task_3(fisrt_group, second_group) 

print(f'Список городов, которые встречаются в обоих списках - {common_cities}')  # ['Санкт-Петербург', 'Москва'] 
# проверочный ответ неправильный так как не отсортирован в алфавитном порядке

"""##### ***Задача 4. Найти количество упоминаний заданного города.***

У списка есть метод `count`, этот метод принимает значение,  
и считает сколько раз он содержится в списке.  

Написать функцию `task_4`, которая принимает два аргумента список городов,  
где нужно искать заданный город.  
И искомый город, количество упоминаний которого нужно подсчитать.
Результатом должно быть количество вхождений города в списке.

Города записанные в разных регистрах, считаются одинаковыми.
"""

list_cities = [  # список городов
    'Новосибирск',
    'Владивосток',
    'Москва',
    'санкт-петербург',
    'Владивосток',
    'Москва',
    'Санкт-Петербург',
    'Москва',
    'Новосибирск',
    'Владивосток',
    'Ижевск',
    'Владивосток',
    'Ижевск',
    'САНКТ-ПЕТЕРБУРГ',
    'Владивосток',
    'Новосибирск',
    'Владивосток',
    'Ижевск',
    'Москва',
    'Санкт-Петербург'
]
find_city = 'Санкт-Петербург'  # искомый город

def task_4(list_, find_task):
    '''
    Функция поиска количества вхождений значения в список без учета регистра
    На первом этапе все значения списка и искомое значение приводятся к нижнему регистру
    На втором этапе методом count подсчитывается количество вхождений
    '''
    find_task_lower = find_task.lower()
    list_city_name_lower = []
    for city_name in list_:
        list_city_name_lower.append(city_name.lower())
    return list_city_name_lower.count(find_task_lower)


count_cities = task_4(list_cities, find_city)

print(f'{find_city} встречается в списке {count_cities} раза (в независимости от регистра букв)')  # 4

"""##### ***Задача 5. Средний индекс озеленения.***

Дан список словарей территорий, где `territory_area` - площадь территории, а `green_zones` список площадей зеленых зон.  
Написать две функции:
- первая будет принимать исходный список городов, и возвращать новый список словарей, в котором для каждой территории посчитан индекс индекс озеленения, как отношение площади зеленых зон к площади территории. Новые словари в списке должен содержать название территории и её индекс озеленения. 
- вторая функция принимает список словарей, в которых посчитаны индексы озеленения для каждой территории и возвращает средний индекс озеленения по всем территориям. 
"""

list_territories = [
    {
        "territory_name": "Пушкин",
        "territory_area": 28676,
        "green_zones": [302, 487, 420, 325, 471, 363, 404]
    },
    {
        "territory_name": "Павловск",
        "territory_area": 21025,
        "green_zones": [360, 375, 223, 258, 345, 296, 303]
    },
    {
        "territory_name": "Петергоф",
        "territory_area": 44274,
        "green_zones": [364, 447, 438, 223, 336, 431, 442]
    },
]

def task_5_1(list_):
    for city in list_:
        city["landscape_index"] = round(sum(city["green_zones"]) / city["territory_area"], 4)
        del city["green_zones"]
        del city["territory_area"]
    return list_

def task_5_2(list_):
    city_green_sum = 0
    for city_green in list_:
        city_green_sum += city_green["landscape_index"]
    return round(city_green_sum / len(list_), 4)

print(f"Средний индекс озеленения для всех городов равен - {task_5_2(task_5_1(list_territories))}")

